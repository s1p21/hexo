---
title: 面试-全
date: 2025-09-19 15:42:02
tags: [面试]
---

### css

#### 1.定位、布局
不同定位的区别，两栏布局、三栏布局，flex布局必会
 两栏布局:浮动布局、flex
 三栏布局:双飞翼布局 三栏都采用左浮动
 
 
```css

 #main{
  background-color:aqua;
  width:100%;
  float:left;
}
#left{
  width:200px;
  background-color:yellow;
  float:left;
  margin-left:-100%;
}
#right{
  width:300px;
  background-color:orange;
  float:left;
  margin-left:-300px;
}
#content{
  margin-left:200px;
  margin-right:300px;
}

 
 <!--中间栏写在最前面-->
<div id = "main">
  <div id="content"></div>
</div>
<div id = "left">
</div>

<div id = "right">
</div>
```

CSS三列布局
- float布局：左边左浮动，右边右浮动，中间margin：0 100px;
- Position布局: 左边left：0; 右边right：0; 中间left: 100px; right: 100px;
- table布局: 父元素 display: table; 左右 width: 100px; 三个元素display: table-cell;
- 弹性(flex)布局:父元素 display: flex; 左右 width: 100px;
- 网格（gird）布局：

#### 2. 对于一些常见css的书写:比如文本溢出显示省略号

```css

text-overflow:ellipsis

#多行
display:-webkit-box
-webkit-line-clamp:2;

```

#### 3. link和@import的区别
- link的功能比较多，可以定义RSS、Rel等作用，而@import只能用于加载css
- 解析到link时，同步加载引到的css，而@import引到的css等到页面加载完成后才被加载
- @import 需要ES5 以上
- link可以js动态导入，@import不行

#### 4. flex
- flex-direction
- justify-content
- align-items
- align-content (多轴线的对齐方式)
- flex-wrap

子 
- flex： 0 1 auto
- 表示flex-grow 为0 flex-shrink 为1 flex basis为auto
- align-self

#### 5.垂直居中和水平居中
- line-height
- absolute+ margin(负值)
- absolute + margin auto
- absolute + translate
- Flex + align-items
- Flex + margin auto
- Flex + align-self
- grid +align-items
- calc

#### 6. BFC
BFC（Block formatting context），即块级格式化上下文，它作为HTML页面上的一个独立渲染区域，只有区域内元素参与渲染，且不会影响其外部元素。简单来说，可以将 BFC 看做是一个“围城”，外面的元素进不来，里面的元素出不去
形成BFC的条件:

1、浮动元素，float 除 none 以外的值；
2、定位元素，position（absolute，fixed）；
3、display 为以下其中之一的值 inline-block，table-cell，table-caption；
4、overflow 除了 visible 以外的值（hidden，auto，scroll）；

BFC 一般用来解决以下几个问题
边距重叠问题
消除浮动问题
自适应布局问题

### js

---
title: 面试-JS
date: 2022-11-29 17:13:37
tags: [面试, JS]
---

#### 1.  js 垃圾回收机制

答:js 的内存泄漏可以通过三个:闭包、全局变量、对象属性循环使用、DOM 节点删除时未解绑事件、计时器引用未及时删除

垃圾回收机制:手动回收和自动回收、自动回收分为对调用栈的数据回收、对调用堆的数据回收、
调用栈的数据回收基于 ESP（记录当前执行状态的指针）来销毁保存在栈的执行上下文；
调用堆的数据回收:v8 把堆分为`新生代`和`老生代`,新生代存放的是生存时间短的对象，老生代存放生存时间长的对象
执行流程:

1.  标记活动对象和非活动对象
2.  回收非活动对象占据的内存
3.  内存整理。整理内存碎片

新生代的垃圾回收，将新生代空间内存分为两个区域，一半是对象区域，一半是空闲区域，当对象区域写满后，需要执行一次垃圾清理操作。在垃圾回收过程中，对使用对象进行标记。在垃圾清理阶段，把存活的对象复制到空闲区域，并有序排列这些对象。同时经过两次垃圾回收依然还存活的对象，将放置在老生区中

老生代的垃圾回收，使用标记清除。通过遍历调用栈，能够到达的元素称为活动对象，没有对象的可以判断为垃圾数据，进行标记。之后进行垃圾清除，这个是直接删除标记数据。清除之后，产生大量不连续的内存碎片，于是产生了标记-整理的过程。对所有的可以活动的对象向一端移动，清理边界以外的内存，从而占据连续的内存块。

#### 2. 模块化
AMD推崇依赖前置，在定义模块的时候就要声明其依赖的模块 CMD推崇就近依赖，只有在用到某个模块的时候再去require
CommonJS通过同步的方式加载模块，其输出的模块是一个拷贝对象，所以修改原的模块不会对被引入的模块内部产生影响，且模块在代码运行的时候加载
es6模块是在代码编译时输出接口即编译时加载，es6是通过命令来指定导出和加载，且导出的是模块中的只读引用，如果原始模块中的值被改变了，那么加载的值也会随之改变，所以是动态引用


##### CommonJS 与 ESM 的区别

实际开发中，经常会将 ESM 和 CommonJS 混用，因此有必要了解它们之间的区别。

###### 动态与静态

CommonJS中对模块依赖的解决是“动态的”，而ESM是静态的。所谓动态，是指模块依赖关系的建立发生在代码运行阶段；而静态是指模块依赖关系的建立发生在代码编译阶段。

CommonJS在运行时才会加载模块，确定模块依赖关系。因此可以在任意地方导入模块，甚至可以通过if语句来判断是否加载某个模块。

ESM的导入、导出语句都是声明式的，导入和导出语句必须位于模块的顶层作用域。它是一种静态的模块结构，在编译阶段就可以分析出模块的依赖关系。相比CommonJS，其具有以下优势：

死代码检测和排除。可以减小打包资源体积。

模块变量类型检查。

编译器优化。CommonJS中不论采用那种方式，本质上导入的都是一个对象。而ESM中，可以直接导入变量，减少了引用层级，程序效率更高。

###### 值拷贝和动态映射

导入一个模块时，CommonJS中获取的是一份值的拷贝，而在ESM中，获取的是值的动态映射，并且这个映射是只读的。


浏览器中 ES6 的模块化支持、node 采用 commonJS 的模块化支持

- es6 `import/export`
- commonjs `require/module.exports/exports`
- amd `require/defined`

`require` 与`import`的区别:

- `require`支持动态导入,`import`不支持

#### 3. 原型和原型链

原型关系：

- 每个 class 都有显示原型 prototype
- 每个实例都有隐式原型 _ proto_
- 实例的* proto*指向对应 class 的 prototype

原型: 在 JS 中，每当定义一个对象（函数也是对象）时，对象中都会包含一些预定义的属性。其中每个函数对象都有一个 prototype 属性，这个属性指向函数的原型对象。

原型链：函数的原型链对象 constructor 默认指向函数本身，原型对象除了有原型属性外，为了实现继承，还有一个原型链指针**proto**,该指针是指向上一层的原型对象，而上一层的原型对象的结构依然类似。因此可以利用**proto**一直指向 Object 的原型对象上，而 Object 原型对象用 Object.prototype.** proto** = null 表示原型链顶端。如此形成了 js 的原型链继承。同时所有的 js 对象都有 Object 的基本防范

特点: JavaScript 对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与之相关的对象也会继承这一改变。



##### ES5与ES6继承的区别
ES5的继承是先创建子类的实例, 然后再创建父类的方法添加到this上.

ES6的继承是先创建父类的实例对象this(必须先调用super方法), 再调用子类的构造函数修改this.

通过关键字class定义类, extends关键字实现继承. 子类必须在constructor方法中调用super方法否则创建实例报错. 因为子类没有this对象, 而是使用父类的this, 然后对其进行加工

super关键字指代父类的this, 在子类的构造函数中, 必须先调用super, 然后才能使用this



#### 执行上下文和闭包

执行上下文就是当前 JavaScript 代码被解析和执行时所在环境的抽象概念， JavaScript 中运行任何的代码都是在执行上下文中运行。 执行上下文的生命周期包括三个阶段：创建阶段→执行阶段→回收阶段，我们重点介绍创建阶段。

闭包就是能够读取其他函数内部变量的函数。在 js 中只有函数内部的子函数才能读取局部变量。所以可以简单的理解为：定义在内部函数的函数。

用途主要有两个：

1）使用闭包可以访问函数中的变量。

2）让变量值始终保持在内存中。
#### 4.介绍节流防抖原理、区别以及应用

节流：事件触发后，规定时间内，事件处理函数不能再次被调用。也就是说在规定的时间内，函数只能被调用一次，且是最先被触发调用的那次。

防抖：多次触发事件，事件处理函数只能执行一次，并且是在触发操作结束时执行。也就是说，当一个事件被触发准备执行事件函数前，会等待一定的时间（这时间是码农自己去定义的，比如 1 秒），如果没有再次被触发，那么就执行，如果被触发了，那就本次作废，重新从新触发的时间开始计算，并再次等待 1 秒，直到能最终执行！

使用场景：
节流：滚动加载更多、搜索框搜的索联想功能、高频点击、表单重复提交……
防抖：搜索框搜索输入，并在输入完以后自动搜索、手机号，邮箱验证输入检测、窗口大小 resize 变化后，再重新渲染。

```js
// 节流
function throttle(fn, delay) {
  let lastTime = 0;
  return function () {
    var nowTime = Data.now();
    if (nowTime - lastTime > delay) {
      fn.call(this);
      lastTime = nowTime;
    }
  };
}

//  防抖
function debounce(fn, delay) {
  var timer = null;
  return function () {
    clearTimeOut(timer);
    timer = setTimeOut(function () {
      fn.apply(this);
    }, delay);
  };
}
```

#### 5. 函数式编程

- 纯函数(确定性函数): 是函数式编程的基础，可以使程序变得灵活，高度可拓展，可维护；

优势:

- 完全独立，与外部解耦；
- 高度可复用，在任意上下文，任意时间线上，都可执行并且保证结果稳定；
- 可测试性极强；

条件:

- 不修改参数；
- 不依赖、不修改任何函数外部的数据；
- 完全可控，参数一样，返回值一定一样: 例如函数不能包含 new Date()或者 Math.rando()等这种不可控因素；
- 引用透明；

#### 6. call、 apply 和 bind 的区别

全局环境下this指向window，箭头函数的this永远指向创建当前词法环境时的this，作为构造函数时，函数中的this指向实例对象
执行上下文在被执行的时候才会创建，创建执行上下文时才会绑定this，所以this的指向永远是在执行时确定

call( this,a,b,c ) 在第一个参数之后的，后续所有参数就是传入该函数的值。apply( this,[a,b,c] ) 只有两个参数，第一个是对象，第二个是数组，这个数组就是该函数的参数。

bind 除了返回是函数以外，它的参数和 call 一样。

共同之处：都可以用来代替另一个对象调用一个方法，将一个函数的对象上下文从初始的上下文改变为由 thisObj 指定的新对象

```js
// 实现bind
Function.prototype.mybind(context,...args) {
    let fun  = this
    function bound(...args2) {
        let self = this instanceof bound?this:context
        return fun.apply(self,args.contact(args2);

    }
    bound.prototype = Object.create(fun.prototype)
    return bound
}

// 实现call
Function.prototype.mycall(context,...args) {
    context.fun = this
    return context.fun(...args)
}
// 实现apply
Function.prototype.myapply = function(context, args) {
    context.fun = this;
    return context.fun(...args);
};
```

#### 7. reduce 参数

arr.reduce(callback,[initialValue])

callback （执行数组中每个值的函数，包含四个参数）

1、previousValue （上一次调用回调返回的值，或者是提供的初始值（initialValue））
2、currentValue （数组中当前被处理的元素）
3、index （当前元素在数组中的索引）
4、array （调用 reduce 的数组）

initialValue （作为第一次调用 callback 的第一个参数。）

手写reduce

```js
Array.prototype.myReduce = function(fn,initialValue) {
  let pre,index
  let arr = this.slice()
  if (initalValue === undefined) {
    pre = arr[0]
    index = 1
  } else {
    pre = initialValue
    index = 0
  }
  for (let i =index;i<arr.length;i++) {
    pre = fn.call(null,pre,arr[i],i,this)
  }
  return pre

}
```

#### 8. 深拷贝

```js
function deepClone=function() {
    const map = new Map()
    function isObject(data) {
        return typeOf data ==='object' && data !==null
    }
    function clone (target) {
        if (isObject(target)) {
            let cloneTarget = Array.isArray(target)?[]:{}
            if (map.get(target)) return map.get(target)
            map.set(target, cloneTarget)
            for (let key in target) {
                cloneTarget[key]=clone(target[key])
            }
            return cloneTarget
        } else {
            return target
        }
    }

    return clone(target)
}
```

#### 9. new 关键字做了什么

做了四件事，1，创建空对象，2，将空对象的`__proto__`指向构造函数的`prototype`3，构造函数的 this 作用域赋给新对象，4，返回原始值需要忽略，返回对象需要正常处理

```js
function _new(constructor, ...arg) {
  // 创建一个空对象
  var obj = {};
  // 空对象的`__proto__`指向构造函数的`prototype`, 为这个新对象添加属性
  obj.__proto__ = constructor.prototype;
  // 构造函数的作用域赋给新对象
  var res = constructor.apply(obj, arg);
  // 返回新对象.如果没有显式return语句，则返回this
  return Object.prototype.toString.call(res) === "[object Object]" ? res : obj;
}
```

#### 10. 判断类型 三种方式 
typeOf、  instanceOf、Object.prototype.toString.call()
typeOf 不能区分Array和Object
instanceOf 不能区分基本类型


#### 11. 手动实现一个 instanceOf

instanceOf 基于原型链

```ts
function isInstanceOf(child, fun) {
  if (typeof fun !== "function") {
    throw new TypeError("arg2 fun is not a function");
  }
  if (child === null) {
    return false;
  }
  if (child.__proto__ !== fun.prototype) {
    return isInstanceOf(child.__proto__, fun);
  }
  return true;
}
```

#### 12. 观察者模式和发布订阅模式

观察者模式是一对多的依赖关系，他表示多个观察者对象同时监听某一个主题对象，当这个主题对象发生变化时，会通知所有观察者，使他们能够自我更新
发布-订阅者模式引入了第三方组件，叫做信息中介，它将订阅者和发布者联系起来，当发布者发生变化时，由信息中介通知订阅者，并进行更新。

- 观察者模式

```js
// 被观察者
class Subject() {
    constructor() {
        this.subs=[]
    }
    add(observer) {
        this.subs.push(observer)
    }
    notiify(...args) {
        this.subs.forEach(ob=>ob.update(...args))
    }
}
// 观察者
class Observer() {
    update(...args) {
        ...
    }
}
```

- 发布-订阅模式

```js
class PubSub() {
    constructor() {
        this.handles=[]
    }

    subscribe(type,fn) {
        if (!this.handles[type]) {
            this.handles[type]=[]
        } else {
        this.handles.push(fn)
        }
    }

    publish(type,...args) {
        if (!this.handles[type]) return
        this.handles[type].forEach(fn=>fn(...args))
    }
}
```

#### 13. 虚拟 DOM 和真实 DOM 的转换

虚拟DOM缺点：在首次渲染时，多了一层虚拟DOM的计算，影响性能

```js
class VDom {
  constructor(tag, data, value, type) {
    this.tag = tag && tag.toLowerCase(); // 节点名
    this.data = data; // 属性
    this.value = value; // 文本数据
    this.type = type; // 节点类型
    this.children = [];
  }
  appendChild(vnode) {
    this.children.push(vnode);
  }

  // nodeName：node的名字，如果是element那名字是大写的,其他的名字前面写上#。

  // nodeType：node的类型，一般用数字表示，1表示element(也可以用Node.ELEMENT_NODE来表示)，3表示text(Node.TEXT_NODE)。
  // 如果是element，那么nodeName === tagName
  // 如果是text，那么nodeName = #text， tagName = undefined

  // nodeValue：当前节点的值，对于text, comment节点来说, nodeValue返回该节点的文本内容，对于 attribute 节点来说, 返回该属性的属性值，而对于document和element节点来说，返回null
}

function getVnode(node) {
  let nodeType = node.nodeType;
  let _vnode = null;
  if (nodeType === "element") {
    let tag = node.nodeName;
    let attrs = node.attributes;
    let _attrObj = {};
    for (let i = 0; i < attrs.length; i++) {
      _attrObj[attrs[i].nodeName] = attrs[i].nodeValue;
    }
    _vnode = new VDom(tag, _attrObj, undefined, nodeType);
    let children = node.childNodes;
    for (let i = 0; i < children.length; i++) {
      _vnode.appendChild(getVNode(children[i]));
    }
  } else if (nodeType === "text") {
    _vnode = new VDom(node, nodeName, undefined, node.nodeValue, nodeType);
  }
  return _vnode;
}
```

虚拟 DOM 转化成 DOM

```js
function parseVNode(vnode) {
  let type = vnode.type;
  let rdom = null;
  if (type === "element") {
    rdom = document.createElement(vnode.tag);
    let attrs = vnode.data;
    for (let key in attrs) {
      rdom.setArribute(key, attrs[key]);
    }
    let children = vnode.children;
    for (let i = 0; i < children.length; i++) {
      rdom.appendChild(parseNode(children[i]));
    }
  } else if (type === "text") {
    rdom = document.createTextNode(vnode.value);
  }
  return rdom;
}
```



#### 15. node 的eventloop
 node的 事件循环有times, pending callbacks(I/o callbacks, idle prepare), poll,check,close callbacks
- times 执行setTimeOut 和setTimeInterval
- check 直接执行setTimeImmediate



#### 16. ajax
readyState 0 表示 请求还未初始化，尚未调用 open() 方法。
1 表示 已建立服务器链接，open() 方法已经被调用。
2 表示 请求已接受，send() 方法已经被调用，并且头部和状态已经可获得。
3 表示 正在处理请求，下载中； responseText 属性已经包含部分数据。
4 表示 完成，下载操作已完成。

```js
function ajax(url, method) {
    return new Promise((resolve, reject) => {
      const xhr = new XMLHttpRequest()
      xhr.open(url, method, true)
      xhr.onreadystatechange = function () {
        if (xhr.readyState === 4) {
          if (xhr.status === 200) {
            resolve(xhr.responseText)
          } else if (xhr.status === 404) {
            reject(new Error('404'))
          }
        } else {
          reject('请求数据失败')
        }
      }
      xhr.send(null)
    })
  }
```


#### 17. flutter 的生命周期
分为两种情况，
一个是statelessWidget 其生命周期是constructor、build、deactive、dispose
另外一个是statefulWidget，其生命周期是constructor、initState、didChangeDependencies,build、didUpdate Widget、deactive、dispose

#### 18. js 加载的async 和defer的区别
async script标签设置了这个值，则说明引入的js需要<strong>异步加载和执行</strong>
在有async的情况下脚本异步加载和执行，并且不会阻塞页面加载，但是也并不会保证其加载的顺序，如果多个async优先执行，则先加载好的js文件，所以使用此方式加载的js文件最好不要包含其他依赖

defer
果使用此属性，也将会使js异步加载执行，且会在文档被解析完成后执行，这样就不会阻塞页面加载，但是它将会按照原来的执行顺序执行，对于有依赖关系的也可使用'

如果只有async，那么脚本在下载完成后异步执行。
如果只有defer，那么脚本会在页面解析完毕之后执行。

#### 19. 虚拟列表
可见区域

* 列表高度是固定的，条数计算
```js
const height = 60
const bufferSize = 5
this.visibleCount = Math.ceil((window.clientHeight||window.screen.height) / height);

```

* 列表高度不固定
通过观察者方式，来观察元素是否进入视口。我们会对固定元素的第一个和最后一个分别打上标签，例如把第一个元素的id设置为top，把最后一个元素的id值设置为bottom。
此时调用异步的api：IntersectionObserver，他能获取到进入到视口的元素，判断当前进入视口的元素是最后个元素，则说明内容是往上滚的，如果进入视口的是第一个元素，则说明内容是往下滚的。
我们依次保存下当前第一个元素距离顶部的高度和距离底部的高度，赋值给滚动内容元素的paddingTop和paddingBottom，这样内容区域的高度就不会坍塌，依旧保持这传统滚动元素充满列表时的内容高度:


#### 20. node 的多个通信
通过socket 和HTTP进行通信
同一台电脑通信可以通过IPC进行通信
PM2 监听node的原理：
pm2包括 Satan进程、God Deamon守护进程、进程间的远程调用rpc、cluster等几个概念
1.Satan.js提供了程序的退出、杀死等方法，因此它是魔鬼；God.js 负责维护进程的正常运行，当有异常退出时能保证重启，所以它是上帝。作者这么命名，我只能说一句：oh my god。
God进程启动后一直运行，它相当于cluster中的Master进程，守护者worker进程的正常运行。

2.rpc（Remote Procedure Call Protocol）是指远程过程调用，也就是说两台服务器A，B，一个应用部署在A服务器上，想要调用B服务器上应用提供的函数/方法，由于不在一个内存空间，不能直接调用，需要通过网络来表达调用的语义和传达调用的数据。同一机器不同进程间的方法调用也属于rpc的作用范畴。

3.代码中采用了axon-rpc 和 axon 两个库，基本原理是提供服务的server绑定到一个域名和端口下，调用服务的client连接端口实现rpc连接。后续新版本采用了pm2-axon-rpc 和 pm2-axon两个库，绑定的方法也由端口变成.sock文件，因为采用port可能会和现有进程的端口产生冲突。

每次命令行的输入都会执行一次satan程序。如果God进程不在运行，首先需要启动God进程。然后根据指令，satan通过rpc调用God中对应的方法执行相应的逻辑。
God在初次执行时会配置cluster，同时监听cluster中的事件：
在God启动后， 会建立Satan和God的rpc链接，然后调用prepare方法。prepare方法会调用cluster.fork，完成集群的启动.

#### 21. 性能指标：
* FP（首次绘制）
* FCP（首次内容绘制 First contentful paint）
* LCP（最大内容绘制时间 Largest contentful paint）
* FPS（每秒传输帧数）
* CLS (累积布局偏移)
* TTI（页面可交互时间 Time to Interactive）
* HTTP 请求响应时间
* DNS 解析时间
* TCP 连接时间

#### 22. interface 和 type 、 泛型位置
interface 只能定义对象类型。type声明可以声明任何类型。

interface 能够声明合并，两个相同接口会合并。Type声明合并会报错
type可以类型推导


// 定义callback遍历方法 两种方式 应该采用哪一种？
`type Callback = <T>(item: T) => void`
// 第二种声明方式
`type Callback<T> = (item: T) => void;`

当泛型出现在内部时，比接口本身并不具备任何泛型定义。而接口代表的函数则会接受一个泛型定义。换句话说接口本身不需要泛型，而在实现使用接口代表的函数类型时需要声明该函数接受一个泛型参数。

当泛型出现在接口中时，比如Callback<T> 代表的是使用接口时需要传入泛型的类型.

#### 24 箭头函数
this的作用域
但是没有prototype属性没有构造器特性，所以也就没有所谓的constructor，就不能作为构造器使用。
箭头函数的作用域不能通过.call、.apply、.bind等语法来改变，这使得箭头函数的上下文将永久不变
箭头函数不能使用关键字arguments来访问，只能通过定义的命名参数来访问。

#### 25 JS 设计模式

- 单例模式
- 工厂模式
- 装饰器模式
- 观察者模式
- 发布-订阅者模式
- 策略模式
- 访问者模式（bable插件）

装饰器模式
在不改变对象自身的基础上，动态地给某个对象添加一些额外的职责
```js
function fuc() {
  console.log(2);
}
Function.prototype.before = function(beFn) {
  let self = this;
  return function() {
    beFn.apply(this, arguments); // 先执行插入到前面的方法，类似于二叉树的前序遍历
    return self.apply(this, arguments); // 后执行当前的方法
  };
};
Function.prototype.after = function(afFn) {
  let self = this;
  return function() {
    self.apply(this, arguments); // 先执行当前的方法
    return afFn.apply(this, arguments); // 后执行插入到后面的方法
  };
};

function fuc1() {
  console.log(1);
}
function fuc3() {
  console.log(3);
}
function fuc4() {
  console.log(4);
}

fuc = fuc.before(fuc1).before(fuc4).after(fuc3);
fuc();
```

访问者模式
在不改变该对象的前提下访问其结构中元素的新方法
```js
// 元素类
class Student {
  constructor(name, chinese, math, english) {
    this.name = name;
    this.chinese = chinese;
    this.math = math;
    this.english = english;
  }

  accept(visitor) {
    visitor.visit(this);
  }
}

// 访问者类
class ChineseTeacher {
  visit(student) {
    console.log(`语文 ${student.chinese}`);
  }
}

class MathTeacher {
  visit(student) {
    console.log(`数学 ${student.math}`);
  }
}

class EnglishTeacher {
  visit(student) {
    console.log(`英语 ${student.english}`);
  }
}

// 实例化元素类
const student = new Student("张三", 90, 80, 60);
// 实例化访问者类
const chineseTeacher = new ChineseTeacher();
const mathTeacher = new MathTeacher();
const englishTeacher = new EnglishTeacher();
// 接受访问
student.accept(chineseTeacher); // 语文90
student.accept(mathTeacher); // 数学80
student.accept(englishTeacher); // 英语60
```

### 26. async await 
作用：用同步方式，执行异步操作

总结

1）async函数是generator（迭代函数）的语法糖

2）async函数返回的是一个Promise对象，有无值看有无return值

3）await关键字只能放在async函数内部，await关键字的作用 就是获取Promise中返回的resolve或者reject的值

4）async、await要结合try/catch使用，防止意外的错误

```js
function generatorToAsync(generatorFn) {
  return function() {
    const gen = generatorFn.apply(this, arguments) // gen有可能传参

    // 返回一个Promise
    return new Promise((resolve, reject) => {

      function go(key, arg) {
        let res
        try {
          res = gen[key](arg) // 这里有可能会执行返回reject状态的Promise
        } catch (error) {
          return reject(error) // 报错的话会走catch，直接reject
        }

        // 解构获得value和done
        const { value, done } = res
        if (done) {
          // 如果done为true，说明走完了，进行resolve(value)
          return resolve(value)
        } else {
          // 如果done为false，说明没走完，还得继续走

          // value有可能是：常量，Promise，Promise有可能是成功或者失败
          return Promise.resolve(value).then(val => go('next', val), err => go('throw', err))
        }
      }

      go("next") // 第一次执行
    })
  }
}

const asyncFn = generatorToAsync(gen)

asyncFn().then(res => console.log(res))
```

#### 27.实现一个批量请求函数

```js
async function run(){
    for (let i=0;i<idArray.length;i++){
        let promise = request(idArray[i]);
        promise.then((res)=>{
            console.log(`id${res}的请求已经处理完毕,当前并发为${pool.length}`);
            pool.splice(pool.indexOf(promise),1);
        })
        pool.push(promise);
        //这里是重点，当满了就阻塞
        if (pool.length==max){
            await Promise.race(pool);
        }
    }
}
run();
```

### 28.Promise then 第二个参数和catch的区别是什么
主要区别就是，如果在then的第一个函数里抛出了异常，后面的catch能捕获到，而then的第二个函数捕获不到。
then的第二个参数和catch捕获错误信息的时候会就近原则，如果是promise内部报错，reject抛出错误后，then的第二个参数和catch方法都存在的情况下，只有then的第二个参数能捕获到，如果then的第二个参数不存在，则catch方法会捕获到。

### 29. promise finally 方法实现
调用当前 Promise 的 then 方法返回一个新的 Promise 对象（保证链式调用）
调用 Promise 中的 resolve 方法进行返回

```js

Promise.prototype.finally = function (callback) {
  return this.then(
    (data) => {
      return Promise.resolve(callback()).then(() => data);
    },
    (err) => {
      return Promise.resolve(callback()).then(() => {
        throw err;
      });
    }
  );
};
```

### 30. sleep函数的多种实现
JS没有语言内置的休眠（sleep or wait）函数，所谓的sleep只是实现一种延迟执行的效果
等待指定时间后再执行对应方法
- 循环阻止
- 定时器
- promise
- async await的promise实现

```js
function sleep1(fn, time) {
  let start = new Date().getTime();
  while (new Date().getTime() - start < time) {
    continue;
  }
  fn();
}

// 方式二： 定时器
function sleep2(fn, time) {
  setTimeout(fn, time);
}

// 方式三：promise
function sleep3(fn, time) {
  new Promise(resolve => {
    setTimeout(resolve, time);
  }).then(() => {
    fn();
  });
}

// 方式四：async await
async function sleep4(fn, time) {
  await new Promise(resolve => {
    setTimeout(resolve, time);
  });
  fn();
}
function fn() { console.log("fn")}

sleep1(fn, 2000);
sleep2(fn, 2000);
sleep3(fn, 2000);
sleep4(fn, 2000);
```

### 手写map
```js
Array.prototype.selfMap = function(fn, content) {
  // map中的第二个参数作为fn函数的this
  // Array.prototype.slice.call将类数组转化为数组，同Array.from, this为调用的数组（arr）
  let arr = Array.prototype.slice.call(this);
  let mappedArr = Array(); // 创建一个空数组
  for (let i = 0; i < arr.length; i++) {
    // 判断稀疏数组，跳过稀疏数组中的空值
    // 稀疏数组：数组中元素的个数小于数组的长度，比如Array(2) 长度为2的稀疏数组
    if (!arr.hasOwnProperty(i)) continue;
    mappedArr[i] = fn.call(content, arr[i]);
  }
  return mappedArr;
};
let arr = [1, 2, 3];
console.log(arr.selfMap(item => item * 2)); // [2, 4, 6]
```

### 前端错误捕获
错误信息分为以下几种：
- JS 代码运行错误、语法错误等
- 异步错误等
- 静态资源加载错误
- 接口请求报错

try/catch 只能捕获常规的运行错误，语法错误和异步错误无法捕获
window.onerror 可以捕获常规的错误、异步错误、但不能捕获资源错误
window.addEventListener 当静态资源加载失败时，会触发error事件
promise错误，无法被以上几种捕获，可通过unhandledrejection 事件来处理
```js
// unhandledrejection 可以捕获Promise中的错误 ✅
window.addEventListener("unhandledrejection", function(e) {
  console.log("捕获到异常", e);
  // preventDefault阻止传播，不会在控制台打印
  e.preventDefault();
});

```

vue 错误 window.onerror 和 error 事件不能捕获到常规的代码错误,vue 通过 Vue.config.errorHander 来捕获异常：
```js
Vue.config.errorHandler = (err, vm, info) => {
    console.log('进来啦~', err);
}
```

React 错误
从 react16 开始，官方提供了 ErrorBoundary 错误边界的功能，被该组件包裹的子组件，render 函数报错时会触发离当前组件最近父组件的ErrorBoundary，生产环境，一旦被 ErrorBoundary 捕获的错误，也不会触发全局的 window.onerror 和 error 事件
react项目中，可以在 componentDidCatch 中将捕获的错误上报

跨域问题：如果当前页面中，引入了其他域名的JS资源，如果资源出现错误，error 事件只会监测到一个 script error 的异常。是由于浏览器基于安全考虑，故意隐藏了其它域JS文件抛出的具体错误信息，这样可以有效避免敏感信息无意中被第三方(不受控制的)脚本捕获到，因此，浏览器只允许同域下的脚本捕获具体的错误信息

接口错误
1）拦截XMLHttpRequest请求示例：
```js
function xhrReplace() {
  if (!("XMLHttpRequest" in window)) {
    return;
  }
  const originalXhrProto = XMLHttpRequest.prototype;
  // 重写XMLHttpRequest 原型上的open方法
  replaceAop(originalXhrProto, "open", originalOpen => {
    return function(...args) {
      // 获取请求的信息
      this._xhr = {
        method: typeof args[0] === "string" ? args[0].toUpperCase() : args[0],
        url: args[1],
        startTime: new Date().getTime(),
        type: "xhr"
      };
      // 执行原始的open方法
      originalOpen.apply(this, args);
    };
  });
  // 重写XMLHttpRequest 原型上的send方法
  replaceAop(originalXhrProto, "send", originalSend => {
    return function(...args) {
      // 当请求结束时触发，无论请求成功还是失败都会触发
      this.addEventListener("loadend", () => {
        const { responseType, response, status } = this;
        const endTime = new Date().getTime();
        this._xhr.reqData = args[0];
        this._xhr.status = status;
        if (["", "json", "text"].indexOf(responseType) !== -1) {
          this._xhr.responseText =
            typeof response === "object" ? JSON.stringify(response) : response;
        }
        // 获取接口的请求时长
        this._xhr.elapsedTime = endTime - this._xhr.startTime;

        // 上报xhr接口数据
        reportData(this._xhr);
      });
      // 执行原始的send方法
      originalSend.apply(this, args);
    };
  });
}

/**
 * 重写指定的方法
 * @param { object } source 重写的对象
 * @param { string } name 重写的属性
 * @param { function } fn 拦截的函数
 */
function replaceAop(source, name, fn) {
  if (source === undefined) return;
  if (name in source) {
    var original = source[name];
    var wrapped = fn(original);
    if (typeof wrapped === "function") {
      source[name] = wrapped;
    }
  }
}
```
拦截fetch为例
```js
function fetchReplace() {
  if (!("fetch" in window)) {
    return;
  }
  // 重写fetch方法
  replaceAop(window, "fetch", originalFetch => {
    return function(url, config) {
      const sTime = new Date().getTime();
      const method = (config && config.method) || "GET";
      let handlerData = {
        type: "fetch",
        method,
        reqData: config && config.body,
        url
      };

      return originalFetch.apply(window, [url, config]).then(
        res => {
          // res.clone克隆，防止被标记已消费
          const tempRes = res.clone();
          const eTime = new Date().getTime();
          handlerData = {
            ...handlerData,
            elapsedTime: eTime - sTime,
            status: tempRes.status
          };
          tempRes.text().then(data => {
            handlerData.responseText = data;
            // 上报fetch接口数据
            reportData(handlerData);
          });

          // 返回原始的结果，外部继续使用then接收
          return res;
        },
        err => {
          const eTime = new Date().getTime();
          handlerData = {
            ...handlerData,
            elapsedTime: eTime - sTime,
            status: 0
          };
          // 上报fetch接口数据
          reportData(handlerData);
          throw err;
        }
      );
    };
  });
}
```


### 首屏加载时间计算
首屏加载时间和首页加载时间不一样，首屏指的是屏幕内的dom渲染完成的时间
比如首页很长需要好几屏展示，这种情况下屏幕以外的元素不考虑在内
计算首屏加载时间流程

1）利用MutationObserver监听document对象，每当dom变化时触发该事件

2）判断监听的dom是否在首屏内，如果在首屏内，将该dom放到指定的数组中，记录下当前dom变化的时间点

3）在MutationObserver的callback函数中，通过防抖函数，监听document.readyState状态的变化

4）当document.readyState === 'complete'，停止定时器和取消对document的监听

5）遍历存放dom的数组，找出最后变化节点的时间，用该时间点减去performance.timing.navigationStart 得出首屏的加载时间


### 图片打点上报的优势：
1）支持跨域，一般而言，上报域名都不是当前域名，上报的接口请求会构成跨域
2）体积小且不需要插入dom中
3）不需要等待服务器返回数据
图片打点缺点是：url受浏览器长度限制

### 浏览器事件循环机制
事件循环其实就是在事件驱动模式中来管理和执行事件的一套流程。包括两种，一种是事件驱动，另外一种是状态驱动或数据驱动。
在事件驱动中，当有事件触发后，被触发的事件会按顺序暂时存在一个队列中，待 JS 的同步任务执行完成后，会从这个队列中取出要处理的事件并进行处理

JS 按顺序执行执行栈中的方法，每次执行一个方法时，会为这个方法生成独有的执行环境（上下文 context)，待这个方法执行完成后，销毁当前的执行环境，并从栈中弹出此方法（即消费完成），然后继续下一个方法。在事件驱动的模式下，至少包含了一个执行循环来检测任务队列是否有新的任务。通过不断循环去取出异步回调来执行，这个过程就是事件循环，而每一次循环就是一个事件周期或称为一次 tick。

事件循环的过程中，执行栈在同步代码执行完成后，优先检查微任务队列是否有任务需要执行，如果没有，再去宏任务队列检查是否有任务执行，如此往复。微任务一般在当前循环就会优先执行，而宏任务会等到下一次循环，因此，微任务一般比宏任务先执行，并且微任务队列只有一个，宏任务队列可能有多个。另外我们常见的点击和键盘等事件也属于宏任务。
根据任务的种类不同，可以分为微任务（micro task）队列和宏任务（macro task）队列。
常见宏任务：setTimeout() setInterval()
常见微任务：promise.then() MutaionObserver nextTick

### 关于SVG 和 Canvas 的区别。

1、SVG 不能绘制图片，而 canvas 可以。SVG是通过 XML 绘制，而Canvas通过 js 绘制
2、Canvas绘制的方式，是通过 js 逐像素渲染的。也就是说，它绘制一个复杂的图形和一个简单的图形的性能是差不多的。
SVG 是通过 XML 的方式渲染。它的本质是DOM，而复杂的图形，就会降低其渲染性能。
3、Canvas 是依赖分辨率，是一种标量图。所以在放缩的时候，存在失真的问题。
SVG 绘制的时候，不依赖分辨率，是一种矢量图。所以当SVG放缩的时候，不会使得图像失真。
4、SVG 适合带有大型渲染区域的应用程序：比如谷歌地图、百度地图。


### promise和async/await 的区别
唯一的区别在于 `promise` 和 `async/await` 的执行上下文。

当创建 Promise 并启动异步操作时，创建 Promise 后的代码会继续同步执行。当 Promise 被解析或拒绝时，附加的回调函数会被添加到微任务队列中。微任务队列会在当前任务完成后，但在下一个任务从任务队列中处理出来之前进行处理。这意味着在创建 Promise 之后的任何代码都将在执行附加到 Promise 的回调函数之前执行。

另一方面，在使用 async/await 时， await 关键字会使 JavaScript 引擎暂停执行 async 函数，直到 Promise 解析或被拒绝。当 async 函数等待 Promise 解析时，它不会阻塞调用栈，因此可以执行任何其他同步代码。一旦 Promise 解析完毕， async 函数将继续执行，并返回 Promise 的结果。如果被拒绝，则会抛出一个错误值。

### webpack



#### loader 和plugin的区别

loader即为文件加载器，操作的是文件，将文件A通过loader转换成文件B，是一个单纯的文件转化过程。
plugin即为插件，是一个扩展器，丰富webpack本身，增强功能 ，针对的是在loader结束之后，webpack打包的整个过程，他并不直接操作文件，而是基于事件机制工作，监听webpack打包过程中的某些节点，执行广泛的任务。

* Loader 特性:
- 链式传递，按照配置时相反的顺序链式执行;
- 基于 Node 环境，拥有 较高权限，比如文件的增删查改; 可同步也可异步;
* 编写原则:
- 单一原则: 每个 Loader 只做一件事;
- 链式调用: Webpack 会按顺序链式调用每个 Loader;
- 统一原则: 遵循 Webpack 制定的设计规则和结构，输入与输出均为字符串，各个 Loader 完全独立，即插即用;

* plugin
在编译的整个生命周期中，Webpack 会触发许多事件钩子， Plugin 可以监听这些事件，根据需求在相应的时间点对打包内容进行定向的修改。

Plugin的组成部分
1）Plugin的本质是一个 node 模块，这个模块导出一个JavaScript 类
2）它的原型上需要定义一个apply 的方法
3）通过compiler获取webpack内部的钩子，获取webpack打包过程中的各个阶段
钩子分为同步和异步的钩子，异步钩子必须执行对应的回调
4）通过compilation操作webpack内部实例特定数据
5）功能完成后，执行webpack提供的cb回调


* 事件流机制
Webpack 就像工厂中的一条产品流水线。原材料经过 Loader 与 Plugin 的一道道处理，最后输出结果。
- 通过链式调用，按顺序串起一个个 Loader;
- 通过事件流机制，让 Plugin 可以插入到整个生产过程中的每个步骤中;

Webpack 事件流编程范式的核心是基础类` Tapable` ，是一种 观察者模式 的实现事件的订阅与广播: 
Webpack 中两个最重要的类 `Compiler` 与 `Compilation` 便是继承于 Tapable，也拥有这样的事件流机制。
- Compiler: 可以简单的理解为 Webpack 实例，它包含了当前 Webpack 中的所有配置信息，如 options， loaders, plugins 等信息，全局唯一，只在启动时完成初始化创建，随着生命周期逐一传递; 
- Compilation: 可以称为 编译实例。当监听到文件发生改变时，Webpack 会创建一个新的 Compilation 对象，开始一次新的编译。它包含了当前的输入资源，输出资源，变化的文件等，同时通过它提供的 api，可 以监听每次编译过程中触发的事件钩子;

区别:
- Compiler 全局唯一，且从启动生存到结束;
- Compilation 对应每次编译，每轮编译循环均会重新创建; 

##### 常用 Plugin:
- UglifyJsPlugin: 压缩、混淆代码;
- Optimization.splitChunks: 代码分割;
- ProvidePlugin: 自动加载模块;
- html-webpack-plugin: 加载 html 文件，并引入 css / js 文件; 
- extract-text-webpack-plugin / mini-css-extract-plugin: 抽离样式，生成 css 文件; 
- DefinePlugin: 定义全局变量;
- optimize-css-assets-webpack-plugin: CSS 代码去重; 
- webpack-bundle-analyzer: 代码分析;
- compression-webpack-plugin: 使用 gzip 压缩 js 和 css; 
- happypack: 使用多进程，加速代码构建; 
- EnvironmentPlugin: 定义环境变量;





#### 优化技巧
缓存、加快打包速度、缩小打包体积

1. 缓存，比如bable-loader 添加cacheDirectory为true来开启缓存
```js
{
    test: /\.js$/,
    loader: 'babel-loader',
    options: {
      cacheDirectory: true
    }
  },
```
cacheLoader


2. 加快打包速度
多核打包，比如使用happyPack/Thread-loader/Parallel-Webpack
高效编译，对于JS的编译选用不同的编译器，比如ESBuild 基于Go语言开发的JavaScript Bundler 和SWC 基于Rust的JavaScript Compiler(其生态中也包含打包工具spack), 目前为Next.JS/Parcel/Deno等前端圈知名项目使用


3、缩小打包体积
- 使用Tree-shaking、减少打包代码
- 对于大的模块引入thread-loader
- 对于不常用的变更抽离出去 ，一种是使用webpack-dll-plugin,在首次构建时候将这些静态依赖打包，另外一种是使用Externals，将这些不常用的静态资源抽离，并用cdn方式引用他们
- compression-webpack-plugin 压缩js和css代码




#### 什么是Tree-Shark

摇树优化 (Tree-shaking)，这是一种形象比喻。我们把打包后的代码比喻成一棵树，这里其实表示的就 是，通过工具 "摇" 我们打包后的 js 代码，将没有使用到的无用代码 "摇" 下来 (删除)。即 消除那些被 引用了但未被使用 的模块代码。
原理: 由于是在编译时优化，因此最基本的前提就是语法的静态分析，ES6的模块机制提供了这种可能性。不需要运行时，便可进行代码字面上的静态分析，确定相应的依赖关系。
问题: 具有副作用的函数无法被 tree-shaking。 在引用一些第三方库，需要去观察其引入的代码 量是不是符合预期; 尽量写纯函数，减少函数的副作用; 可使用 webpack-deep-scope-plugin， 可以进行作用域分析，减少此类情况的发生，但仍需要注意;


#### performance 对象api
属性
- memory
- navigation 
- timing
![](https://img-blog.csdnimg.cn/20200717141446763.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTQ0ODE0MDU=,size_16,color_FFFFFF,t_70)

方法
- getEntries() 这个函数返回的将是一个数组，包含了页面中所有的 HTTP 请求
- now()  输出的是相对于 performance.timing.navigationStart(页面初始化) 的时间, Date.now() 输出的是 UNIX 时间，即距离 1970 的时间 
- mark()  performance.mark() 标记各种时间戳（就像在地图上打点），保存为各种测量值（测量地图上的点之间的距离），便可以批量地分析这些数据了。


后来 window.performance.timing 被废弃，通过 PerformanceObserver 旧的 api，返回的是一个 UNIX 类型的绝对时间，和用户的系统时间相关，分析的时候需要再次计算。而新的 api，返回的是一个相对时间，可以直接用来分析


### 热更新
开发过程中，代码发生变动后，webpack会重新编译，编译后浏览器替换修改的模块，局部更新，无需刷新整个页面

主要是通过websocket实现，建立本地服务和浏览器的双向通信。当代码变化，重新编译后，通知浏览器请求更新的模块，替换原有的模块
1） 通过webpack-dev-server开启server服务，本地server启动之后，再去启动websocket服务，建立本地服务和浏览器的双向通信
2） webpack每次编译后，会生成一个Hash值，Hash代表每一次编译的标识。本次输出的Hash值会编译新生成的文件标识，被作为下次热更新的标识
3）webpack监听文件变化（主要是通过文件的生成时间判断是否有变化），当文件变化后，重新编译
4）编译结束后，通知浏览器请求变化的资源，同时将新生成的hash值传给浏览器，用于下次热更新使用
5）浏览器拿到更新后的模块后，用新模块替换掉旧的模块，从而实现了局部刷新


### 模块联邦
webpack5 模块联邦(Module Federation) 使 JavaScript应用，得以从另一个 JavaScript应用中动态的加载代码，实现共享依赖，用于前端的微服务化
比如项目A和项目B，公用项目C组件，以往这种情况，可以将C组件发布到npm上，然后A和B再具体引入。当C组件发生变化后，需要重新发布到npm上，A和B也需要重新下载安装
使用模块联邦后，可以在远程模块的Webpack配置中，将C组件模块暴露出去，项目A和项目B就可以远程进行依赖引用。当C组件发生变化后，A和B无需重新引用
模块联邦利用webpack5内置的ModuleFederationPlugin插件，实现了项目中间相互引用的按需热插拔


### 一个简单的AST示例
let a = 1，转化成AST的结果
```js
{
  "type": "Program",
  "start": 0,
  "end": 9,
  "body": [
    {
      "type": "VariableDeclaration",
      "start": 0,
      "end": 9,
      "declarations": [
        {
          "type": "VariableDeclarator",
          "start": 4,
          "end": 9,
          "id": {
            "type": "Identifier",
            "start": 4,
            "end": 5,
            "name": "a"
          },
          "init": {
            "type": "Literal",
            "start": 8,
            "end": 9,
            "value": 1,
            "raw": "1"
          }
        }
      ],
      "kind": "let"
    }
  ],
  "sourceType": "module"
}

```


### koa和express的区别
express框架是一个基于 Node.js 平台的极简、灵活的 web 应用开发框架，主要基于 Connect 中间件，并且自身封装了路由、视图处理等功能。

koa是 Express 原班人马基于 ES6 新特性重新开发的框架，主要基于 co 中间件，框架自身不包含任何中间件，很多功能需要借助第三方中间件解决，但是由于其基于 ES6 generator 特性的异步流程控制，解决了 "callback hell" 和麻烦的错误处理问题。

相同点
两个框架都对http进行了封装。相关的api都差不多，同一批人所写。

不同点
express内置了许多中间件可供使用，而koa没有。

express包含路由，视图渲染等特性，而koa只有http模块。

express的中间件模型为线型，而koa的中间件模型为U型，也可称为洋葱模型构造中间件。

express通过回调实现异步函数，在多个回调、多个中间件中写起来容易逻辑混乱。


### node的错误监控
try catch 通常用于捕获throw抛出的错误

callback(err, result)回调函数处理

Emitter.on的回调函数 on注册了事件和回调函数， 并且在emit触发事件后会执行回调函数，以达到捕获错误的解决方式。


process.on("error", function(err){})
错误异常有两种场景的出现：

一种是代码运行中throw new error没有被捕获，另一种是Promise的失败回调函数，没有对应的reject回调函数处理，针对这两种情况Nodejs都有默认的统一处理方式，就是给整个进程process对象监听相应的错误事件。
process.on('uncaughtException',function(err){}) //监听未捕获的异常
process.on('unhandledRejection',function(err,promise){}) //监听Promise没有被捕获的失败函数


### 网络



#### 网络模型
应用层、表示层、会话层、传输层、网络层、数据链路层、物理层

#### http的请求报文和返回报文
* 请求报文：
- accept-charset
- accept-encoding
- accept-language
- Host
- User-agent
- connection
- cookie
- If-Modified-Since

* 返回报文
- server
- content-type
- content-encoding
- content-language
- keep-alive
- ETag
- cache-control
- Expires
- last-Modified
- access-control-allow-origin：



#### tcp和udp 的区别
tcp：面向连接、传输可靠，可用于传输大量数据,速度慢，建立连接需要开销较多
udp: 面向非连接、传输不可靠、用于传输少量数据(数据包模式)、速度快 ,可能丢包


#### http和https的区别
多了一层SSL加密，
客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。服务器公钥放在数字证书中。

#### http2.0 和http1 的区别
- 多路复用：相同域名多个请求，共享同一个TCP连接，降低了延迟
- 请求优先级：给每个request设置优先级
- 服务端推送：可以主动向客户端发送消息。
- 头部压缩：减少包的大小跟数量

#### tcp 三次握手
客户端 发送SYN 包
服务端接受并发生SYN+ACK包
客户端接受ACK包并发送至服务端，建立连接

#### tcp 四次挥手
客户端发出FIN包，进入FIN-WAIT
服务端发出确认报文 ACK 进入 CLOSE-WAIT
服务端发送连接释放报文，进入LAST-ACK
客户端发出ACK，等待2*MSL（最长报文段寿命）进入closed状态



#### http code
1xx：信息，请求收到，继续处理 
2xx：成功，行为被成功地接受、理解和采纳 
3xx：重定向，为了完成请求，必须进一步执行的动作 
4xx：客户端错误，请求包含语法错误或者请求无法实现 
5xx：服务器错误，服务器不能实现一种明显无效的请求 

200 OK：客户端请求成功
201 用户新建或修改数据成功
202 一个请求已经进入后台
204 No Content：无内容。服务器成功处理，但未返回内容。一般用在只是客户端向服务器发送信息，而服务器不用向客户端返回什么信息的情况。不会刷新页面。
206 Partial Content：服务器已经完成了部分GET请求（客户端进行了范围请求）。响应报文中包含Content-Range指定范围的实体内容

301 Moved Permanently：永久重定向，表示请求的资源已经永久的搬到了其他位置。

302 Found：临时重定向，表示请求的资源临时搬到了其他位置

303 See Other：临时重定向，应使用GET定向获取请求资源。303功能与302一样，区别只是303明确客户端应该使用GET访问

307 Temporary Redirect：临时重定向，和302有着相同含义。POST不会变成GET

304 Not Modified：表示客户端发送附带条件的请求（GET方法请求报文中的IF…）时，条件不满足。返回304时，不包含任何响应主体。虽然304被划分在3XX，但和重定向一毛钱关系都没有


400 Bad Request：客户端请求有语法错误，服务器无法理解。
401 Unauthorized：请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用。
403 Forbidden：服务器收到请求，但是拒绝提供服务
404 Not Found：请求资源不存在。比如，输入了错误的url
415 Unsupported media type：不支持的媒体类型

500 Internal Server Error：服务器发生不可预期的错误。
502 网关错误
503 Server Unavailable：服务器当前不能处理客户端的请求，一段时间后可能恢复正常
504 网关超时
505 HTTP版本未被支持


#### websocket的连接原理

轮询
客户端通过一定的时间间隔以频繁请求的方式向服务器发送请求，来保持客户端和服务器端的数据同步。问题很明显，当客户端以固定频率向服务器端发送请求时，服务器端的数据可能并没有更新，带来很多无谓请求，浪费带宽，效率低下。

从上文可以看出，传统 Web 模式在处理高并发及实时性需求的时候，会遇到难以逾越的瓶颈，我们需要一种高效节能的双向通信机制来保证数据的实时传输。在此背景下，基于 HTML5 规范的、有 Web TCP 之称的 WebSocket 应运而生。

WebSocket 是 HTML5 一种新的协议。它实现了浏览器与服务器全双工通信，能更好的节省服务器资源和带宽并达到实时通讯，它建立在 TCP 之上，同 HTTP 一样通过 TCP 来传输数据，但是它和 HTTP 最大不同是：

WebSocket 是一种双向通信协议，在建立连接后，WebSocket 服务器和 Browser/Client Agent 都能主动的向对方发送或接收数据，就像 Socket 一样；
WebSocket 需要类似 TCP 的客户端和服务器端通过握手连接，连接成功后才能相互通信。


#### 跨域
跨域是指一个域下的文档或脚本试图去请求另一个域下的资源

什么是同源策略？
同源策略/SOP（Same origin policy）是一种约定，由Netscape公司1995年引入浏览器，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到XSS、CSRF等攻击。所谓同源是指"协议+域名+端口"三者相同，即便两个不同的域名指向同一个ip地址，也非同源。
同源策略限制以下几种行为：
1. Cookie、LocalStorage 和 IndexDB 无法读取
2. DOM 和 Js对象无法获得
3. AJAX 请求不能发送

跨域解决方案
1、 通过jsonp跨域
2、 document.domain + iframe跨域
3、 location.hash + iframe
4、 window.name + iframe跨域
5、 postMessage跨域
6、 跨域资源共享（CORS）
7、 nginx代理跨域
8、 nodejs中间件代理跨域
9、 WebSocket协议跨域

#### 预检请求

预检请求是在进行跨域资源共享 CORS 时，由浏览器自动发起的一种 OPTIONS 请求。它的存在是为了保障安全，并允许服务器决定是否允许跨域请求。

跨域请求是指在浏览器中向不同域名、不同端口或不同协议的资源发送请求。出于安全原因，浏览器默认禁止跨域请求，只允许同源策略。而当网页需要进行跨域请求时，浏览器会自动发送一个预检请求，以确定是否服务器允许实际的跨域请求。

预检请求中包含了一些额外的头部信息，如 Origin 和 Access-Control-Request-Method 等，用于告知服务器实际请求的方法和来源。服务器收到预检请求后，可以根据这些头部信息，进行验证和授权判断。如果服务器认可该跨域请求，将返回一个包含 Access-Control-Allow-Origin 等头部信息的响应，浏览器才会继续发送实际的跨域请求。

使用预检请求机制可以有效地防范跨域请求带来的安全风险，保护用户数据和隐私。

### CSP
该安全策略的实现基于一个称作 Content-Security-Policy的 HTTP 首部。
可以移步MDN，有更加规范的解释。我在这里就是梳理一下吧。
CSP，即浏览器中的内容安全策略，它的核心思想大概就是服务器决定浏览器加载哪些资源，具体来说有几个功能
* 限制加载其他域下的资源文件，这样即使黑客插入了一个 JavaScript 文件，这个 JavaScript 文件也是无法被加载的；
* 禁止向第三方域提交数据，这样用户数据也不会外泄；
* 提供上报机制，能帮助我们及时发现 XSS 攻击。
* 禁止执行内联脚本和未授权的脚本；


### React


#### react生命周期
- constructor（并不属于生命周期 - 初始化 state，初始化参数）
- static getDerivedStateFormPorps - 组件 props 变化时更新 state
- componentDidMount - 网络请求，添加监听事件等
- shouldComponentUpdate - 通过判断新传入的 props，优化性能，避免重复渲染
- static getSnapshopBeforeUpdate - 很少用，组件更新之前捕获一些信息（例如滚动位置）
- componentDidUpdate - 组件更新完成后的一些操作
- componentWillUnmount - 卸载监听事件，卸载计时器等
- componentDidUnmount()

#### react Fiber

React 的核心流程可以分为两个部分:

reconciliation (调度算法，也可称为 render):

更新 state 与 props；
调用生命周期钩子；
生成 virtual dom；

这里应该称为 Fiber Tree 更为符合；


通过新旧 vdom 进行 diff 算法，获取 vdom change；
确定是否需要重新渲染

- Render 阶段就是根据每个组件中的状态构建出一个新的 UI Tree，也叫WorkInProgress Tree，并为每一个结点对应的操作打上 EffectTag，即更新、删除、新增。全部构建完成后就进入下一阶段。



commit:
- Commit 阶段就是将构建好的 WIP Tree 反应到浏览器中，即 React 为我们自动进行相应的 dom 操作，保持 UI 一致性。
如需要，则操作 dom 节点更新；

要了解 Fiber，我们首先来看为什么需要它？

问题: 随着应用变得越来越庞大，整个更新渲染的过程开始变得吃力，大量的组件渲染会导致主进程长时间被占用，导致一些动画或高频操作出现卡顿和掉帧的情况。而关键点，便是 同步阻塞。在之前的调度算法中，React 需要实例化每个类组件，生成一颗组件树，使用 同步递归 的方式进行遍历渲染，而这个过程最大的问题就是无法 暂停和恢复。

解决方案: 解决同步阻塞的方法，通常有两种: 异步 与 任务分割。而 React Fiber 便是为了实现任务分割而诞生的。


简述:

在 React V16 将调度算法进行了重构， 将之前的 stack reconciler 重构成新版的 fiber reconciler，变成了具有链表和指针的 单链表树遍历算法。通过指针映射，每个单元都记录着遍历当下的上一步与下一步，从而使遍历变得可以被暂停和重启。
这里我理解为是一种 任务分割调度算法，主要是 将原先同步更新渲染的任务分割成一个个独立的 小任务单位，根据不同的优先级，将小任务分散到浏览器的空闲时间执行，充分利用主进程的事件循环机制。



核心:

Fiber 这里可以具象为一个 数据结构:

```ts
class Fiber {
	constructor(instance) {
		this.instance = instance
		// 指向第一个 child 节点
		this.child = child
		// 指向父节点
		this.return = parent
		// 指向第一个兄弟节点
		this.sibling = previous
	}	
}
```

链表树遍历算法: 通过 节点保存与映射，便能够随时地进行 停止和重启，这样便能达到实现任务分割的基本前提；

1、首先通过不断遍历子节点，到树末尾；
2、开始通过 sibling 遍历兄弟节点；
3、return 返回父节点，继续执行2；
4、直到 root 节点后，跳出遍历；



任务分割，React 中的渲染更新可以分成两个阶段:

reconciliation 阶段: vdom 的数据对比，是个适合拆分的阶段，比如对比一部分树后，先暂停执行个动画调用，待完成后再回来继续比对。
Commit 阶段: 将 change list 更新到 dom 上，并不适合拆分，才能保持数据与 UI 的同步。否则可能由于阻塞 UI 更新，而导致数据更新和 UI 不一致的情况。



分散执行: 任务分割后，就可以把小任务单元分散到浏览器的空闲期间去排队执行，而实现的关键是两个新API: `requestIdleCallback` 与 `requestAnimationFrame`

低优先级的任务交给`requestIdleCallback`处理，这是个浏览器提供的事件循环空闲期的回调函数，需要 pollyfill，而且拥有 deadline 参数，限制执行事件，以继续切分任务；
高优先级的任务交给`requestAnimationFrame`处理；


```ts
// 类似于这样的方式
requestIdleCallback((deadline) => {
    // 当有空闲时间时，我们执行一个组件渲染；
    // 把任务塞到一个个碎片时间中去；
    while ((deadline.timeRemaining() > 0 || deadline.didTimeout) && nextComponent) {
        nextComponent = performWork(nextComponent);
    }
});
```
优先级策略: 文本框输入 > 本次调度结束需完成的任务 > 动画过渡 > 交互反馈 > 数据更新 > 不会显示但以防将来会显示的任务

Fiber 其实可以算是一种编程思想，在其它语言中也有许多应用(Ruby Fiber)。核心思想是 任务拆分和协同，主动把执行权交给主线程，使主线程有时间空挡处理其他高优先级任务。


#### react 优化
pureComponent 浅比较
shouldComponentUpdate 深比较

hooks优化
React.memo
react.
useMemo useMemo 是一种缓存机制提速，当它的依赖未发生改变时，就不会触发重新计算。
useCallback  针对传入子组件的为函数，进行优化使用，因为函数式组件每次发生渲染，都会从头执行，两次的callBack函数发生了改变，导致子组件渲染。useCallback 针对函数进行记忆，从而避免触发渲染。


#### setState 是异步还是同步的？
在React管理的事件回调和生命周期中，是异步的，其他是同步的，因为来做批量更新，减少渲染。
但在函数式组件中不存在这个问题。因为函数组件中生成的函数是通过闭包引用了 state，而不是通过 this.state 的方式引用 state，所以函数组件的处理函数中 state 一定是旧值，不可能是新值。可以说函数组件已经将这个问题屏蔽掉了。


#### Redux
state
Action
reducer 处理state


#### 函数式编程
纯函数 
函数复合
数据不可变性
函数式编程其实是一种编程思想，它追求更细的粒度，将应用拆分成一组组极小的单元函数，组合调用操作数据流；
它提倡着 纯函数 / 函数复合 / 数据不可变， 谨慎对待函数内的 状态共享 / 依赖外部 / 副作用；


#### 高阶组件
react 中的 HOC 高阶组件，就是一个函数，接受一个组件作为参数，返回一个新的组件
例如一个loading的高阶组件

```ts
// high order component
import React from 'react'
import axios from 'axios'

interface ILoaderState {
  data: any,
  isLoading: boolean
}
interface ILoaderProps {
  data: any,
}
const withLoader = <P extends ILoaderState>(WrappedComponent: React.ComponentType<P>, url: string) => {
  return class LoaderComponent extends React.Component<Partial<ILoaderProps>, ILoaderState> {
    constructor(props: any) {
      super(props)
      this.state = {
        data: null,
        isLoading: false
      }
    }
    componentDidMount() {
      this.setState({
        isLoading: true,
      })
      axios.get(url).then(result => {
        this.setState({
          data: result.data,
          isLoading: false
        })
      })
    }
    render() {
      const { data, isLoading } = this.state
      return (
        <>
          { (isLoading || !data) ? <p>data is loading</p> :
            <WrappedComponent {...this.props as P} data={data} />
          }
        </>
      )
    }
  }
}

export default withLoader

```
使用实例：

```ts
interface IShowResult{
    message:string,
    status:string
}
//定义一个组件
const DogShow:React.FC<{data:IShowResult}> = ({data})=>{
    return (
        <>
            <h2>show:{data.status}</h2>
            <img src={data.message}/>
        </>
    )
}

const App:React.FC=()=>{
    //高阶组件，将一个组件用参数形式传入，然后经过包裹后返回一个新的组件，达到公用包裹组件的功能
    const WrappedDogShow = withLoader(DogShow,'https://dog.ceo/api/breeds/image/random');
    return (
        <WrappedDogShow/>
    )
}
```

#### React hooks
其实，React hooks 的问题也有很多，比如：

- Hook 是一个链表的结构，在循环，条件或嵌套函数中调用 Hook，会引发一些问题。
- useEffect 的依赖容易造成心智负担，所有人阅读这段代码，都需要完整的阅读完这些依赖触发的地方
- 由于闭包的原因，useEffect 等内部捕获的，都是过时的变量。

对 React Hooks 而言，调用必须放在最前面，而且不能被包含在条件语句里，这是因为 React Hooks 采用下标方式寻找状态，一旦位置不对或者 Hooks 放在了条件中，就无法正确找到对应位置的值。
所有 Hooks 都在渲染闭包中执行，每次重渲染都有一定性能压力，而且频繁的渲染会带来许多闭包，虽然可以依赖 GC 机制回收，但会给 GC 带来不小的压力。
需要用useCallback、useMemo 来做性能优化，两者的区别在于一个存储函数的本身(useCallback) 一个存储函数返回的值（useMemo）

useLayoutEffect
跟 useEffect 使用差不多，通过同步执行状态更新可解决一些特性场景下的页面闪烁问题
useLayoutEffect 会阻塞渲染，请谨慎使用

* DOM更新同步钩子。用法与useEffect类似，只是区别于执行时间点的不同。
* useEffect属于异步执行，并不会等待 DOM 真正渲染后执行，而useLayoutEffect则会真正渲染后才触发；
* 可以获取更新后的 state；


useReducer

接收一个形如 (state, action) => newState 的 reducer，并返回当前的 state 以及与其配套的 dispatch 方法
* reducer 本质是一个纯函数，每次只返回一个值，那个值可以是数字，字符串，对象，数组或者对象，但是它总是一个值
* React 会确保 dispatch 函数的标识是稳定的，并且不会在组件重新渲染时改变
* useReducer 还能给那些会触发深更新的组件做性能优化，因为可以向子组件传递 dispatch 而不是回调函数
* reducer 更适合去处理比较复杂的 state，来维护组件的状态

类似于 Redux 思想的实现，但其并不足以替代 Redux，可以理解成一个组件内部的 redux:
  * 并不是持久化存储，会随着组件被销毁而销毁；
  * 属于组件内部，各个组件是相互隔离的，单纯用它并无法共享数据；
  * 配合useContext的全局性，可以完成一个轻量级的 Redux；(easy-peasy)

useContext

* 接收一个 context 对象（React.createContext 的返回值）并返回该 context 的当前值
* useContext 的参数必须是 context 对象本身
* 当前的 context 值由上层组件中距离当前组件最近的 <MyContext.Provider> 的 value prop 决定
* 调用了 useContext 的组件总会在 context 值变化时重新渲染

#### React diff
要求：1、跨层级节点移动操作较少；2、相同类的两个组件会生成相似的树形结构；3、同一层的一组节点，通过唯一的key进行区分
树差异（Tree Diff）、组件差异（Component Diff）以及元素差异（Element Diff）
树差异 只比较同一层级，如果同一层级不同，直接先销毁再创建
组件差异 同一类型的组件，比较子树， 如果不是，直接替换
元素差异，直接通过唯一的key来辨别



#### umi & dva
umi 企业级的前端开发框架，Umi 以路由为基础的，同时支持配置式路由和约定式路由，保证路由的功能完备，并以此进行功能扩展。然后配以生命周期完善的插件体系，覆盖从源码到构建产物的每个生命周期，支持各种功能扩展和业务需求。

特性：插件化、MFSU
![](images/umi.png)

dva 是基于redux的前端数据流方案
特性：
- 易学易用

特点：
modal、namespace、state、effect、reducer、subscription
- effect:以 key/value 格式定义 effect。用于处理异步操作和业务逻辑，不直接修改 state
- reducer:以 key/value 格式定义 reducer。用于处理同步操作，唯一可以修改 state 的地方，由 action 触发
- subscription:以 key/value 格式定义 subscription。subscription 是订阅，用于订阅一个数据源，然后根据需要 dispatch 相应的 action。在 app.start() 时被执行，数据源可以是当前的时间、服务器的 websocket 连接、keyboard 输入、geolocation 变化、history 路由变化等等。


### Vue


#### vue 的双向绑定

vue2.x 中通过发布者-订阅者设计模式的方式实现，通过 get 和 set 方法，通过 Object.defineProperty() 实现数据劫持
有三个参数，对象，对象的属性，以及描述符对象
描述符对象： 数据属性：

- writable 可读写
- enumerable 可迭代，表示是否可用 for in 循环
- configurable 是否可删除
- value 值

访问器属性

- get
- set

同时需要遍历所有属性进行双向绑定

缺点：对于新增的属性无法监听，需要通过 vm.$set 方法新增属性；

vue3 中通过 proxy 的 api 来实现监听
proxy 有两个参数
target:要使用 Proxy 包装的目标对象（可以是任何类型的对象，包括原生数组，函数，甚至另一个代理）
handler:一个通常以函数作为属性的对象，各属性中的函数分别定义了在执行各种操作时代理 p 的行为。

#### vue 的生命周期

vue2.x

beforeCreate
created
beforeMount
mounted
beforeUpdate
updated
beforeDestory
destoryed

加载渲染过程
父 beforeCreate -> 父 created -> 父 beforeMount-> 子 beforeCreate -> 子 created -> 子 beforeMount -> 子 mounted -> 父 mounted

子组件更新过程
父 beforeUpdate -> 子 beforeUpdate -> 子 updated -> 父 updated

父组件更新过程
父 beforeUpdate -> 父 updated

销毁过程
父 beforeDestroy -> 子 beforeDestroy -> 子 destroyed -> 父 destroyed

vue3
setup
onBeforeMount
onMounted
onBeforeUpdated
onUpdated
onBeforeUnmount
onUnmounted

#### vuex 和 pinia

vuex 分为 State、Getter、Mutation、Action、Module
dispatch 方法操作->action->commit 方法->mutation
State 是状态，mapState 通常用来解决一个组件需要获取多个状态时的辅助函数；
Getter state 对象读取方法，用来计算 state 然后生成新的数据，相当于对于部分 state 重新封装了一层
Mutation 对 state 进行改变的唯一方法，其中 Mutation 必须是同步的
Action 是通过触发 Mutation 从而改变 state，可以包含任意异步操作，其中通过 store.dispatch 进行触发
Module 可以说是对 store 进行分割，每一个 module 拥有自己的 state，mutation，action，getter 等。命名空间使得模块的封装和复用更加方便
插件使用使得 vuex 扩展性更好，表单处理的双向绑定需要绑定事件或者通过计算属性的 setter 进行双向绑定

缺点：

1. TS 支持不良好
2. 不能同时支持 Composition API 和 Option API（vuex5 之后支持）

pinia

1. 去掉了容易混淆的 mutation 和 action 概念，只保留了 action，action 中的函数可以是同步的也可以是异步的，并且可以直接调用 action 中的方法，不再需要 commit、dispatch 等方法，语法更简洁；
2. 无需创建自定义复杂包装器来支持 TypeScript，所有内容都是类型化的，并且 API 的设计方式尽可能地利用了 TS 的类型推断；
3. 不再有 modules 的嵌套结构。 Pinia 通过设计提供平面结构，同时仍然支持 Store 之间的交叉组合方式；
4. 更加轻便 Pinia 大小约 1kb

#### nextTick

在下次 DOM 更新循环结束之后执行延迟回调，在修改数据之后立即使用 nextTick 来获取更新后的 DOM。 nextTick 主要使用了宏任务和微任务。 根据执行环境分别尝试采用 Promise、MutationObserver、setImmediate，如果以上都不行则采用 setTimeout 定义了一个异步方法，多次调用 nextTick 会将方法存入队列中，通过这个异步方法清空当前队列。

1. nextTick 是 Vue 提供的一个全局 API,是在下次 DOM 更新循环结束之后执行延迟回调，在修改数据之后使用$nextTick，则可以在回调中获取更新后的 DOM；
2. Vue 在更新 DOM 时是异步执行的。只要侦听到数据变化，Vue 将开启 1 个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个 watcher 被多次触发，只会被推入到队列中-次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。nextTick 方法会在队列中加入一个回调函数，确保该函数在前面的 dom 操作完成后才调用；
3. 比如，我在干什么的时候就会使用 nextTick，传一个回调函数进去，在里面执行 dom 操作即可；
4. 我也有简单了解 nextTick 实现，它会在 callbacks 里面加入我们传入的函数，然后用 timerFunc 异步方式调用它们，首选的异步方式会是 Promise。这让我明白了为什么可以在 nextTick 中看到 dom 操作结果。

#### v-model 语法糖和 vue3 的 v-model 变化

value+input 是 v-band 和 v-on 的简洁写法
在 vue2 中 v-model 只能绑定在组件的 value 属性上
在 2.x 版本中 可以在组件内部定义一个 model 项，其中 prop 用来设置 v-model 中默认的 value 的别名， event 用来设置 v-model 中默认的 input 事件的别名
一个组件上只能一个 v-model

在 vue3 中 v-bind 的.sync 修饰符和组件的 model 选项被删除了
支持同一组件同时设置多个 v-model
也可以自定义修饰符
v-model 绑定的不再是 value，而是 modelValue，接收的方法也不再是 input，而是 update:modelValue

#### vue 的通信方式

- 父子：props 和$emit
- 爷孙：$attrs和$listeners
- eventbus
- provide 和 inject
- $parent 和$children
- vuex
- 自定义 store

#### Object.defineProperty 处理 Array 的 push

需要重新处理 push 方法

```js
const originProto = Array.prototype;
const arrayProto = Object.create(originProto);
arrayProto["push"] = function () {
  originProto.push().apply(this, arguments);
  console.log("jjjkjkjk");
};
data.__proto__ = arrayProto;
Object.defineProperty(data, "push", {
  set: (newVal) => {
    console.log("kkkkjj");
    render();
  },
});
```

#### proxy 的写法

```js
data = new Proxy(data, {
  set: (target, key, value, receiver) => {
    console.log("key", key);
    target[key] = value;
    // Reflect.set(target.key,value,receiver)
    render();
    return true;
  },
});
```

#### 浏览器回退、切换会触发 vue 的哪些生命周期

页面刷新时, vue 执行的生命周期钩子
依次执行当前页面 vue 组件的 beforeCreate, created, beforeMount, mounted, beforUpdate, updated

页面后退时, vue 执行的生命周期钩子
假设从 b 页面后退到 a 页面
依次执行 a 页面 vue 组件的 beforeCreate, created, beforeMount, 然后是 b 页面组件的 beforeDestroy, destroyed, 最后是执行 a 页面 vue 组件的 mounted, beforUpdate, updated

页面前进时, vue 执行的生命周期钩子
假设从 a 页面到 b 页面
依次执行 b 页面 vue 组件的 beforeCreate, created, beforeMount, 然后是 a 页面组件的 beforeDestroy, destroyed, 最后是执行 b 页面 vue 组件的 mounted, beforUpdate, updated

#### vue 中的 diff

在 vue1.0 中，通过 watch 来实现数据和视图的响应式更新，通过观察者模式
在 vue2.x 中，因为还是无法解决响应式数据过多而引起的卡顿的问题，vue2.x 引入了虚拟 DOM，对于 Vue 2 来说，组件之间的变化，可以通过响应式来通知更新。组件内部的数据变化，则通过虚拟 DOM 去更新页面。这样就把响应式的监听器，控制在了组件级别，而虚拟 DOM 的量级，也控制在了组件的大小。

如果没有绑定 key，对于 DOM 的顺序发生变化，比如直接插入，会导致后面的数据不变的组件重新渲染

#### vue 的 keep-alive 的作用是什么？怎么实现的？如何刷新的?

保持组件不被销毁，组件挂载的数据还存在，所以状态就可以保留。
在首次加载被包裹组建时，由 keep-alive.js 中的 render 函数可知，vnode.componentInstance 的值是 undfined，keepAlive 的值是 true，因为 keep-alive 组件作为父组件，它的 render 函数会先于被包裹组件执行；那么只执行到 i(vnode,false)，后面的逻辑不执行；
再次访问被包裹组件时，vnode.componentInstance 的值就是已经缓存的组件实例，那么会执行 insert(parentElm, vnode.elm, refElm)逻辑，这样就直接把上一次的 DOM 插入到父元素中。

在 patch 的阶段，最后会执行 invokeInsertHook 函数，而这个函数就是去调用组件实例（VNode）自身的 insert 钩子：
在 insert 这个钩子里面，调用了 activateChildComponent 函数递归地去执行所有子组件的 activated 钩子函数：
相反地，deactivated 钩子函数也是一样的原理，在组件实例（VNode）的 destroy 钩子函数中调用 deactivateChildComponent 函数。

#### render 和 template 的区别

template----html 的方式做渲染
render----js 的方式做渲染
render（提供）是一种编译方式
render 里有一个函数 h，这个 h 的作用是将单文件组件进行虚拟 DOM 的创建，然后再通过 render 进行解析。
h 就是 createElement()方法：createElement(标签名称,属性配置,children)
template 也是一种编译方式，但是 template 最终还是要通过 render 的方式再次进行编译。

render 渲染方式可以让我们将 js 发挥到极致，因为 render 的方式其实是通过 createElement()进行虚拟 DOM 的创建。逻辑性比较强，适合复杂的组件封装。
template 是类似于 html 一样的模板来进行组件的封装。
render 的性能比 template 的性能好很多
render 函数优先级大于 template

#### vue3 生命周期实现原理

就是把各个生命周期的函数挂载或者叫注册到组件的实例上，然后等到组件运行到某个时刻，再去组件实例上把相应的生命周期的函数取出来执行。
各个生命周期的 Hooks 函数是通过 createHook 这个函数创建的。createHook 是一个闭包函数，通过闭包缓存当前是属于哪个生命周期的 Hooks,target 表示该生命周期 Hooks 函数被绑定到哪个组件实例上，默认是当前工作的组件实例。createHook 底层又调用了一个 injectHook 的函数，那么下面我们继续来看看这个 injectHook 函数。

Vue3 组件实例化之后，通过 effect 包装一个更新的副作用函数来和响应式数据进行依赖收集。在这个副作用函数里面有两个分支，第一个是组件挂载之前执行的，也就是生命周期函数 beforeMount 和 mount 调用的地方，第二个分支是组件挂载之后更新的时候执行的，在这里就是生命周期函数 beforeUpdate 和 updated 调用的地方。具体就是在挂载之前，还没生成虚拟 DOM 之前就执行 beforeMount 函数，之后则去生成虚拟 DOM 经过 patch 之后，组件已经被挂载到页面上了，也就是页面上显示视图了，这个时候就去执行 mount 函数;在更新的时候，还没获取更新之后的虚拟 DOM 之前执行 beforeUpdate，然后去获取更新之后的虚拟 DOM，然后再去 patch，更新视图，之后就执行 updated。需要注意的是 beforeMount 和 beforeUpdate 是同步执行的，都是通过 invokeArrayFns 来调用的

Vue 的 Hooks 设计是从 React 的 Hooks 那里借鉴过来的，React 的 Hooks 的本质就是把状态变量、副作用函数存到函数组件的 fiber 对象上，等到将来状态变量发生改变的时候，相关的函数组件 fiber 就重新进行更新。Vue3 这边的实现原理也类似，通过上面的生命周期的 Hooks 实现原理，我们可以知道 Vue3 的生命周期的 Hooks 是绑定到具体的组件实例上，而状态变量，则因为 Vue 的变量是响应式的，状态变量会通过 effect 和具体的组件更新函数进行依赖收集，然后进行绑定，将来状态变量发生改变的时候，相应的组件更新函数会重新进入调度器的任务队列进行调度执行。

所以 Hooks 的本质就是让那些状态变量或生命周期函数和组件绑定起来，组件运行到相应时刻执行相应绑定的生命周期函数，那些绑定的变量发生改变的时候，相应的组件也重新进行更新。

#### 组件设计原则

单一职责： 一个组件负责完成一个职责/功能
保持简单：不要过度优化，从而牺牲了代码可读性和可维护性
不要重复：做好代码的复用性
控制反转：子组件的创建与管理交给外层容器组件来控制
关注点分离：如果一个问题能分解为独立且较小的问题，就是相对较易解决的。实现关注点分离的方式有两种：一种是标准化，另一种就是抽象与包装
松耦合：组件的核心思想是它们是可复用的,为此要求它们必须具有功能性和完整性。“耦合”是指实体彼此依赖的术语。松散耦合的实体应该能够独立运行，而不依赖于其他模块。就前端组件而言，耦合的主要部分是组件的功能依赖于其父级及其传递的 props 的多少，以及内部使用的子组件（当然还有引用的部分，如第三方模块或用户脚本）。在设计组件时，你应该考虑到更加通用的使用场景，而不仅仅只是为了满足最开始某个特定场景的需求。虽然一般来说组件最初都是出于特定目的进行设计，但没关系，如果在设计它们站在更高的角度去看待，那么很多组件将具有更好的适用性。

#### vue router3 和 vue router4 的区别

1. 创建方式：在Vue Router 4中，使用createRouter来创建一个路由实例，而在Vue Router 3中，则是通过创建一个VueRouter实例来进行。

```js
//  4.x 写法
import { createRouter } from "vue-router"
const router = createRouter({
    // options
    .....
})

// 3.x 写法
import VueRouter from "vue-router"
const router = new VueRouter({
    // options
    ......
})
```

2. 路由模式的定义方式：在Vue Router 4中，使用createWebHistory或createWebHashHistory来定义路由模式，而在Vue Router 3中，则是通过在路由实例中设置mode属性来定义。

```js
//  4.x 写法
import {
  createRouter,
  createWebHistory,
  createWebHashHistory,
} from "vue-router";
const router = createRouter({
  history: createWebHistory() / createWebHashHistory(),
});

// 3.x 写法
const router = new VueRouter({
  mode: "hash" / "history",
});
```

3. 挂载方式：在Vue 3中使用Composition API，所以Vue Router也要以插件的形式进行挂载。在Vue Router 4中，使用useRouter和useRoute两个API来在组件中获取到路由实例和路由对象。而在Vue Router 3中，则是直接在组件实例中使用this.$router来获取路由实例，并使用this.$route来获取路由对象。

```js
// 4.x

import { createApp } from "vue";
import router from "./router.js";
import App from "./App.vue";
createApp(App).use(router).mount("#app");

// 3.x

import router from "./router.js";
new Vue({
  router,
});
```

4. 组件中的使用方式：因为在Vue 3的setup函数中无法使用this，所以在Vue Router 4中提供了useRouter和useRoute两个API来在组件中获取到路由实例和路由对象。而在Vue Router 3中，则是在组件的实例方法中使用this.$router来获取路由实例，并使用this.$route来获取路由对象。

```js
// 4.x
import { useRouter,useRoute } from "vue-router"
export default({
    setup(){
    const router = useRouter();
    const route = useRoute();
    const linkToHome = () => {
        router.push({
            path:'/'
        })
    }
    return{
        linkToHome
    }
    }
})

// 3.x

export default({
    methods:{
        linkToHome(){
        this.$router.push({
                path:'/'
            })
        }
    }
})

```

5. 导航守卫：由于Vue 3的Composition API变革，beforeRouteUpdate 和 beforeRouteLeave 被替换为 onBeforeRouteUpdate 和 onBeforeRouteLeave。


#### app.use 操作了什么？
在Vue中，app.use是Vue的全局API之一，用于在Vue应用程序中引入和注册插件。

app.use操作会调用Vue构造器的use方法，该方法接受一个插件对象或模块作为参数。当调用app.use时，Vue会将插件对象或模块的原型链与Vue构造器的原型链进行合并，这样插件就可以访问Vue的核心API和功能。

具体来说，app.use操作会执行以下操作：

引入插件：如果参数是一个对象，它将作为插件对象被引入。插件对象的属性可以包含要注册的插件功能。
注册插件：如果参数是一个模块，它将被作为插件模块进行注册。这意味着它的属性和方法将被添加到Vue的全局API中，可以在整个应用程序中使用。
合并原型链：无论是引入插件对象还是注册插件模块，Vue都会将它们的原型链与Vue构造器的原型链进行合并。这样，插件就可以访问Vue的核心API和功能，例如this.$createElement、this.$set等。
通过app.use可以方便地将第三方库或自定义插件集成到Vue应用程序中，实现扩展和定制化功能，是Vue开发中常见的一种扩展方式。






