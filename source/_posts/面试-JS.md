---
title: 面试-JS
date: 2022-11-29 17:13:37
tags: [面试, JS]
---

#### 1. 说下 js的内存泄漏，什么情况容易出现内存泄漏？怎么解决？垃圾回收机制是怎么样的？
答:js的内存泄漏可以通过三个:闭包、全局变量、对象属性循环使用、DOM节点删除时未解绑事件、计时器引用未及时删除

垃圾回收机制:手动回收和自动回收、自动回收分为对调用栈的数据回收、对调用堆的数据回收、
调用栈的数据回收基于ESP（记录当前执行状态的指针）来销毁保存在栈的执行上下文；
调用堆的数据回收:v8把堆分为`新生代`和`老生代`,新生代存放的是生存时间短的对象，老生代存放生存时间长的对象
执行流程:
 1. 标记活动对象和非活动对象
 2. 回收非活动对象占据的内存
 3. 内存整理。整理内存碎片

新生代的垃圾回收，将新生代空间内存分为两个区域，一半是对象区域，一半是空闲区域，当对象区域写满后，需要执行一次垃圾清理操作。在垃圾回收过程中，对使用对象进行标记。在垃圾清理阶段，把存活的对象复制到空闲区域，并有序排列这些对象。同时经过两次垃圾回收依然还存活的对象，将放置在老生区中

老生代的垃圾回收，使用标记清除。通过遍历调用栈，能够到达的元素称为活动对象，没有对象的可以判断为垃圾数据，进行标记。之后进行垃圾清除，这个是直接删除标记数据。清除之后，产生大量不连续的内存碎片，于是产生了标记-整理的过程。对所有的可以活动的对象向一端移动，清理边界以外的内存，从而占据连续的内存块。

#### 2. 模块化
浏览器中ES6的模块化支持、node采用commonJS的模块化支持
分类

- es6 `import/export`
- commonjs `require/module.exports/exports`
- amd `require/defined`

`require` 与`import`的区别:

- `require`支持动态导入,`import`不支持

#### 3. 原型和原型链

原型关系：

- 每个 class都有显示原型 prototype
- 每个实例都有隐式原型 _ proto_
- 实例的_ proto_指向对应 class 的 prototype

原型:  在 JS 中，每当定义一个对象（函数也是对象）时，对象中都会包含一些预定义的属性。其中每个函数对象都有一个prototype 属性，这个属性指向函数的原型对象。

原型链：函数的原型链对象constructor默认指向函数本身，原型对象除了有原型属性外，为了实现继承，还有一个原型链指针__proto__,该指针是指向上一层的原型对象，而上一层的原型对象的结构依然类似。因此可以利用__proto__一直指向Object的原型对象上，而Object原型对象用Object.prototype.__ proto__ = null表示原型链顶端。如此形成了js的原型链继承。同时所有的js对象都有Object的基本防范

特点:  JavaScript对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与之相关的对象也会继承这一改变。

#### 4.介绍节流防抖原理、区别以及应用

节流：事件触发后，规定时间内，事件处理函数不能再次被调用。也就是说在规定的时间内，函数只能被调用一次，且是最先被触发调用的那次。

防抖：多次触发事件，事件处理函数只能执行一次，并且是在触发操作结束时执行。也就是说，当一个事件被触发准备执行事件函数前，会等待一定的时间（这时间是码农自己去定义的，比如 1 秒），如果没有再次被触发，那么就执行，如果被触发了，那就本次作废，重新从新触发的时间开始计算，并再次等待 1 秒，直到能最终执行！

使用场景：
节流：滚动加载更多、搜索框搜的索联想功能、高频点击、表单重复提交……
防抖：搜索框搜索输入，并在输入完以后自动搜索、手机号，邮箱验证输入检测、窗口大小 resize 变化后，再重新渲染。

```js
// 节流
function throttle(fn,delay) {
    let lastTime = 0
    return function() {
        var nowTime = Data.now()
        if (nowTime-lastTime>delay) {
            fn.call(this)
            lastTime = nowTime
        }
    }

}

//  防抖
function debounce(fn,delay) {
    var timer = null
    return function() {
        clearTimeOut(timer)
        timer = setTimeOut(function(){
            fn.apply(this)
        },delay)
    }

}

```

#### 5. 函数式编程

- 纯函数(确定性函数): 是函数式编程的基础，可以使程序变得灵活，高度可拓展，可维护；

优势:
- 完全独立，与外部解耦；
- 高度可复用，在任意上下文，任意时间线上，都可执行并且保证结果稳定；
- 可测试性极强；

条件:
- 不修改参数；
- 不依赖、不修改任何函数外部的数据；
- 完全可控，参数一样，返回值一定一样: 例如函数不能包含new Date()或者Math.rando()等这种不可控因素；
- 引用透明；





