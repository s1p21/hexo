---
title: 面试-算法
date: 2022-12-04 19:23:59
tags: [面试,算法]
---

### 1.排序

#### 1.1 快排
```js
var quickSort = function (a, l, r) {
  var i = l;
  var j = r;
  if (l < r) {
    x = a[i];
    while (i !== j) {
      while (i < j && a[j] >= x) {
        j--;
      }
      while (i < j && a[i] <= x) {
        i++;
      }
      if (i < j) {
       [a[j],a[i]] = [a[i],a[j]];

      }
    }
    [a[l],a[i]] = [a[i],x];
    quickSort(a, l, i - 1);
    quickSort(a, i + 1, r);
  }
  return a;
};
```

快排核心是先找到数字的位置，然后两边分别是该数字的小值和大值，其时间复杂度为O(nlogn)

### 2.排列组合

#### 2.1 全排列
```js
function peru(arr){
    let len = arr.length
    let res = []
    const dfs = (tempArr=[],leftArr) =>{
        if (tempArr.length === len) {
            console.log(tempArr,'temp')
            res.push(tempArr)
        } else {
            leftArr.forEach((item,index)=>{
                let temp = [...leftArr]
                temp.splice(index,1)
                dfs(tempArr.concat(item),temp)
            })
        }

     }
     dfs([],arr)
     return res
}

console.log(peru([1,2,3,4]))

```

#### 2.2 组合

```js 
var combine = function (n, k) {
  const res = []
  function dfs(cur,n,k,temp) {
      if (temp.length+(n-cur+1)<k) {
          return
      }
      if (temp.length===k) {
          res.push(temp)
          return 
      }
      dfs(cur+1,n,k,[...temp,cur])
      dfs(cur+1,n,k,temp)
  }
  dfs(1,n,k,[])
  return res
}
```

### 3. 背包问题
```js
const pack=(total)=>{
    const value=[6,3,5,4,6]
    const weights=[2,2,6,5,4]
    const m = value.length
    const n = total
    // dp[i][j]表示有i件商品，最大承重为j的最大价值，
    const dp=[]
    // 如果选择第i件商品
    // dp[i][j]=dp[i-1][j-weights[i]]+values[i]
    // 如果不选择第i件商品
    // dp[i][j]=dp[i-1][j]
    for (let i =1;i<=m;i++) {
        for (let j = 1;j<=n;j++) {
            if (j<weights[i-1]) {
                dp[i][j]=dp[i-1][j]
            } else {
                dp[i][j]= Math.max(dp[i-1][j],dp[i-1][j-weights[i-1]]+values[i-1])
            }
        }
    }
    return dp
}

```


### 4. 动态规划
#### 4.1 最长公共子序列

```js
const longString=(nums1=[],nums2=[])=>{
    const dp = new Array(nums1.length+1).fill(new Array(nums2.length+1).fill(0))
    // dp[i][j]表示第一个数组前i个元素第二个数组前j个元素的最长公共子序列
    for (let i = 1;i<=nums1.length;i++) {
        for (let j = 1;j<=nums2.length;j++) {
            if (nums1[i]===nums2[j]) {
                dp[i][j]=dp[i-1][j-1]+1
            } else {
                dp[i][j]= Math.max(dp[i-1][j],dp[i][j-1])
            }
        }
    }
    return dp
}
```

#### 4.2 最长上升子序列

```js
const fn=(arr)=>{
    const dp = new Array(arr.length).fill(1)
    for (let i = 1;i<arr.length;i++) {
        for (let j = 0;j<i;j++) {
            if (arr[i]>arr[j]) {
                dp[i]= Math.max(dp[i],dp[j]+1)
            } 
        }
    }
    return dp
}
```

### 5. 树的遍历
```js
// 前序遍历
var preorderTraversal = function(root) {
    if(!root) return [];
    const arr = [];
    preorderTraversal1(root, arr);
    return arr;
};

var preorderTraversal1 = function(root, arr){
    arr.push(root.val);
    if(root.left) preorderTraversal1(root.left, arr);
    if(root.right) preorderTraversal1(root.right, arr);
}


// 中序遍历
var inorderTraversal = function(root) {
    if(!root) return [];
    const arr = [];
    inorderTraversal1(root, arr);
    return arr;
};


var inorderTraversal1 = function(root, arr){
    if(root.left) inorderTraversal1(root.left, arr);
    arr.push(root.val);
    if(root.right) inorderTraversal1(root.right, arr);
}

// 后续遍历
var postorderTraversal = function(root) {
    if(!root) return [];
    const arr = [];
    postorderTraversal1(root, arr);
    return arr;
};
var postorderTraversal1 = function(root, arr){
    if(root.left) postorderTraversal1(root.left, arr);
    if(root.right) postorderTraversal1(root.right, arr);
     arr.push(root.val);
}

// 层序遍历
var levelOrder = function(root){
    let values = [];
    if(!root) return values;
    let queue = [];
    let levelList = [];
    queue.push(root);
    let levelLength = queue.length;
    while(queue.length){
        const current = queue.shift();
        levelList.push(current.val);
        if(current.left) queue.push(current.left);
        if(current.right) queue.push(current.right);
        levelLength--;
        if(levelLength === 0){ // 当上一层长度递减到0，队列里剩下的数量，就是下一层数量
            levelLength = queue.length;
            values.push(levelList);
            levelList = [];
        }
    }
    return values;

}
```