---
title: 面试-算法
date: 2022-12-04 19:23:59
tags: [面试,算法]
---

### 1.排序

#### 1.1 快排
```js
var quickSort = function (a, l, r) {
  var i = l;
  var j = r;
  if (l < r) {
    x = a[i];
    while (i !== j) {
      while (i < j && a[j] >= x) {
        j--;
      }
      while (i < j && a[i] <= x) {
        i++;
      }
      if (i < j) {
       [a[j],a[i]] = [a[i],a[j]];

      }
    }
    [a[l],a[i]] = [a[i],x];
    quickSort(a, l, i - 1);
    quickSort(a, i + 1, r);
  }
  return a;
};
```

快排核心是先找到数字的位置，然后两边分别是该数字的小值和大值，其时间复杂度为O(nlogn)

### 2.排列组合

#### 2.1 全排列
```js
function peru(arr){
    let len = arr.length
    let res = []
    const dfs = (tempArr=[],leftArr) =>{
        if (tempArr.length === len) {
            console.log(tempArr,'temp')
            res.push(tempArr)
        } else {
            leftArr.forEach((item,index)=>{
                let temp = [...leftArr]
                temp.splice(index,1)
                dfs(tempArr.concat(item),temp)
            })
        }

     }
     dfs([],arr)
     return res
}

console.log(peru([1,2,3,4]))

```

#### 2.2 组合

```js 
var combine = function (n, k) {
  const res = []
  function dfs(cur,n,k,temp) {
      if (temp.length+(n-cur+1)<k) {
          return
      }
      if (temp.length===k) {
          res.push(temp)
          return 
      }
      dfs(cur+1,n,k,[...temp,cur])
      dfs(cur+1,n,k,temp)
  }
  dfs(1,n,k,[])
  return res
}
```
